import express from 'express';
import { Octokit } from '@octokit/rest';
import { authMiddleware } from '../middleware/auth.js';
import { CreateIssueRequest, IssueType } from '../types/index.js';

const router = express.Router();

router.use(authMiddleware);

function generateBranchName(type: IssueType, title: string, timestamp?: number): string {
  const sanitizedTitle = title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 30);

  const prefix = {
    [IssueType.FEATURE]: 'feature',
    [IssueType.BUG]: 'hotfix',
    [IssueType.TASK]: 'task',
    [IssueType.EPIC]: 'epic',
  };

  const baseName = sanitizedTitle || 'new_issue';
  const suffix = timestamp ? `_${timestamp}` : '';

  return `${prefix[type]}/${baseName}${suffix}`;
}

async function createUniqueBranch(octokit: any, owner: string, repo: string, type: IssueType, title: string, baseBranch = 'main') {
  let branchName = generateBranchName(type, title);
  let attempt = 0;
  const maxAttempts = 5;

  // First, get the base branch reference and handle if it doesn't exist
  let baseRef;
  try {
    const response = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${baseBranch}`,
    });
    baseRef = response.data;
  } catch (error: any) {
    if (error.status === 404) {
      // Try 'master' as fallback
      try {
        const response = await octokit.rest.git.getRef({
          owner,
          repo,
          ref: `heads/master`,
        });
        baseRef = response.data;
        baseBranch = 'master';
      } catch (masterError: any) {
        if (masterError.status === 404) {
          throw new Error(`Repository has no main branch. Please ensure the repository has at least one commit and a default branch (main or master).`);
        }
        throw masterError;
      }
    } else {
      throw error;
    }
  }

  while (attempt < maxAttempts) {
    try {
      // Check if branch already exists
      try {
        await octokit.rest.git.getRef({
          owner,
          repo,
          ref: `heads/${branchName}`,
        });
        // If we get here, branch exists, try with timestamp
        const timestamp = Date.now() + attempt;
        branchName = generateBranchName(type, title, timestamp);
        attempt++;
        continue;
      } catch (error: any) {
        // Branch doesn't exist, we can create it
        if (error.status === 404) {
          break;
        }
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }

  if (attempt >= maxAttempts) {
    throw new Error('Unable to generate unique branch name after multiple attempts');
  }

  // Create the new branch
  const { data: newBranch } = await octokit.rest.git.createRef({
    owner,
    repo,
    ref: `refs/heads/${branchName}`,
    sha: baseRef.object.sha,
  });

  return { branchName, newBranch, baseBranch };
}

async function createInitialCommitOnBranch(octokit: any, owner: string, repo: string, branchName: string, issueKey: string, title: string) {
  try {
    // Get the current branch reference
    const { data: branchRef } = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${branchName}`,
    });

    // Get the current commit
    const { data: currentCommit } = await octokit.rest.git.getCommit({
      owner,
      repo,
      commit_sha: branchRef.object.sha,
    });

    // Create a simple README or ISSUE file for this branch
    const fileName = `ISSUE_${issueKey}.md`;
    const fileContent = `# ${issueKey}: ${title}

This branch was created for issue: ${title}

## Issue Details
- Issue Key: ${issueKey}
- Branch: ${branchName}
- Created: ${new Date().toISOString()}

## TODO
- [ ] Implement the changes for this issue
- [ ] Add tests
- [ ] Update documentation
- [ ] Ready for review

---
*This file was auto-generated by GitHub Manager*
`;

    // Create blob for the file
    const { data: blob } = await octokit.rest.git.createBlob({
      owner,
      repo,
      content: Buffer.from(fileContent).toString('base64'),
      encoding: 'base64',
    });

    // Create tree with the new file
    const { data: tree } = await octokit.rest.git.createTree({
      owner,
      repo,
      base_tree: currentCommit.tree.sha,
      tree: [
        {
          path: fileName,
          mode: '100644',
          type: 'blob',
          sha: blob.sha,
        },
      ],
    });

    // Create commit
    const { data: commit } = await octokit.rest.git.createCommit({
      owner,
      repo,
      message: `feat: Initialize branch for ${issueKey}

Created initial commit for issue: ${title}

- Added issue tracking file
- Ready for development

Issue: ${issueKey}`,
      tree: tree.sha,
      parents: [currentCommit.sha],
    });

    // Update branch reference
    await octokit.rest.git.updateRef({
      owner,
      repo,
      ref: `heads/${branchName}`,
      sha: commit.sha,
    });

    return commit;
  } catch (error) {
    console.error('Failed to create initial commit:', error);
    // Don't throw error, just log it - PR creation will be skipped
    return null;
  }
}

function generateIssueKey(projectId: string, issueNumber: number): string {
  const projectPrefix = projectId.toUpperCase().substring(0, 4);
  return `${projectPrefix}-${issueNumber}`;
}

router.post('/create', async (req, res) => {
  const {
    projectId,
    title,
    description,
    type,
    priority,
    labels = [],
    reporterId,
    assigneeIds = [],
    estimatedHours,
    actualHours,
    dueDate,
    epicId,
    parentId,
    wbsStructure,
  }: CreateIssueRequest = req.body;

  const [owner, repo] = projectId.split('/');

  try {
    const octokit = new Octokit({
      auth: req.user.accessToken,
    });

    // Create unique branch
    const { branchName, newBranch, baseBranch } = await createUniqueBranch(octokit, owner, repo, type, title);

    const issueLabels = [
      ...labels,
      type.toLowerCase(),
      priority.toLowerCase(),
    ];

    const assignees = assigneeIds.length > 0 ? assigneeIds : [reporterId];

    const issueBody = `
**Description:**
${description || 'No description provided'}

**Issue Details:**
- **Type:** ${type}
- **Priority:** ${priority}
- **Estimated Hours:** ${estimatedHours || 'Not specified'}
- **Actual Hours:** ${actualHours || 'Not specified'}
- **Due Date:** ${dueDate ? new Date(dueDate).toLocaleDateString() : 'Not specified'}
- **Epic ID:** ${epicId || 'None'}
- **Parent Issue:** ${parentId || 'None'}
- **Reporter:** ${reporterId}

**Work Breakdown Structure:**
${wbsStructure ? JSON.stringify(wbsStructure, null, 2) : 'Not specified'}

**Branch:** \`${branchName}\`

---
*This issue was created through GitHub Manager*
    `.trim();

    const { data: issue } = await octokit.rest.issues.create({
      owner,
      repo,
      title,
      body: issueBody,
      labels: issueLabels,
      assignees,
    });

    const issueKey = generateIssueKey(projectId, issue.number);

    await octokit.rest.issues.update({
      owner,
      repo,
      issue_number: issue.number,
      title: `[${issueKey}] ${title}`,
    });

    // Create initial commit on the branch to enable PR creation
    const initialCommit = await createInitialCommitOnBranch(octokit, owner, repo, branchName, issueKey, title);

    // Create pull request only if we successfully created an initial commit
    let pr = null;
    if (initialCommit) {
      try {
        const { data: prData } = await octokit.rest.pulls.create({
          owner,
          repo,
          title: `[${issueKey}] ${title}`,
          head: branchName,
          base: baseBranch,
          body: `Closes #${issue.number}\n\n${issueBody}`,
          draft: true,
        });
        pr = prData;
      } catch (prError) {
        console.error('Failed to create PR:', prError);
        // Continue without PR - at least we have the issue and branch
      }
    }

    res.json({
      success: true,
      issue: {
        ...issue,
        key: issueKey,
        branch: branchName,
      },
      pullRequest: pr,
      branch: {
        name: branchName,
        url: `https://github.com/${owner}/${repo}/tree/${branchName}`,
      },
      hasInitialCommit: !!initialCommit,
      notes: pr ? 'Issue, branch, and pull request created successfully!' : 'Issue and branch created successfully. Pull request creation was skipped.',
    });
  } catch (error) {
    console.error('Error creating issue:', error);
    res.status(500).json({
      error: 'Failed to create issue',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

export default router;